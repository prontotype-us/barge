// Generated by CoffeeScript 1.10.0
var Binding, DEFAULT_HOST, DEFAULT_PROTO, EventEmitter, MAX_BIND_RETRIES, VERBOSE, helpers, log, util, zmq,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

zmq = require('zmq');

util = require('util');

EventEmitter = require('events').EventEmitter;

helpers = require('./helpers');

log = helpers.log;

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

DEFAULT_HOST = process.env.SOMATA_HOST || '127.0.0.1';

MAX_BIND_RETRIES = 5;

module.exports = Binding = (function(superClass) {
  extend(Binding, superClass);

  Binding.prototype.pending_responses = {};

  Binding.prototype.subscriptions = {};

  Binding.prototype.known_pings = {};

  function Binding(options) {
    if (options == null) {
      options = {};
    }
    Object.assign(this, options);
    this.id || (this.id = helpers.randomString());
    this.proto || (this.proto = DEFAULT_PROTO);
    this.host || (this.host = DEFAULT_HOST);
    if (this.proto !== 'ipc') {
      this.port || (this.port = helpers.randomPort());
    }
    this.should_retry = options.port == null;
    this.tryBind();
  }

  Binding.prototype.emitNext = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return process.nextTick((function(_this) {
      return function() {
        return _this.emit.apply(_this, args);
      };
    })(this));
  };

  Binding.prototype.tryBind = function(n_retried) {
    var err, error;
    if (n_retried == null) {
      n_retried = 0;
    }
    try {
      this.address = helpers.makeAddress(this.proto, this.host, this.port);
      if (VERBOSE) {
        log.d("[Binding.tryBind] Attempting to bind on " + this.address + "...");
      }
      this.socket = zmq.socket('router');
      this.socket.bindSync(this.address);
      return this.didBind();
    } catch (error) {
      err = error;
      log.e("[Binding.tryBind] Failed to bind on " + this.address, err);
      if (!this.should_retry) {
        return process.exit();
      } else if (n_retried < MAX_BIND_RETRIES) {
        log.w("[Binding.tryBind] Retrying...");
        this.port = helpers.randomPort();
        return setTimeout((function(_this) {
          return function() {
            return _this.tryBind(n_retried + 1);
          };
        })(this), 1000);
      } else {
        log.e("[Binding.tryBind] Retried too many times.");
        return process.exit();
      }
    }
  };

  Binding.prototype.didBind = function() {
    if (VERBOSE) {
      log.i("[Binding.didBind] Socket " + this.id + " bound to " + this.address);
    }
    this.emitNext('bind');
    this.socket.on('message', (function(_this) {
      return function(client_id, message_json) {
        return _this.handleMessage(client_id.toString(), JSON.parse(message_json));
      };
    })(this));
    this.on('ping', this.handlePing.bind(this));
    this.on('method', this.handleMethod.bind(this));
    this.on('subscribe', this.handleSubscribe.bind(this));
    return this.on('unsubscribe', this.handleUnsubscribe.bind(this));
  };

  Binding.prototype.handleMessage = function(client_id, message) {
    var cb, ref;
    if (VERBOSE > 1) {
      log.d("[Binding.handleMessage] <" + client_id + "> " + (helpers.summarizeMessage(message)));
    }
    if (cb = (ref = this.pending_responses[client_id]) != null ? ref[message.id] : void 0) {
      return cb(message);
    } else {
      return this.emit(message.kind, client_id, message);
    }
  };

  Binding.prototype.handlePing = function(client_id, message) {
    var pong;
    if (message.ping === 'hello' || (this.known_pings[message.id] == null)) {
      this.known_pings[message.id] = true;
      this.emitNext('connected', client_id);
      pong = 'welcome';
    } else {
      pong = 'pong';
    }
    this.setPingTimeout(client_id);
    return this.send(client_id, {
      id: message.id,
      kind: 'pong',
      pong: pong
    });
  };

  Binding.prototype.ping_timeouts = {};

  Binding.prototype.setPingTimeout = function(client_id) {
    var pingDidTimeout;
    clearTimeout(this.ping_timeouts[client_id]);
    pingDidTimeout = this.pingDidTimeout.bind(this, client_id);
    return this.ping_timeouts[client_id] = setTimeout(pingDidTimeout, 2500);
  };

  Binding.prototype.clearSubscriptions = function(client_id) {
    var ref, results, subscription, subscription_id, subscription_type, subscriptions;
    ref = this.subscriptions;
    results = [];
    for (subscription_type in ref) {
      subscriptions = ref[subscription_type];
      results.push((function() {
        var ref1, results1;
        results1 = [];
        for (subscription_id in subscriptions) {
          subscription = subscriptions[subscription_id];
          if (subscription.client_id === client_id) {
            delete this.subscriptions[subscription_type][subscription_id];
            results1.push((ref1 = this.pending_responses[client_id]) != null ? delete ref1[subscription_id] : void 0);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  Binding.prototype.pingDidTimeout = function(client_id) {
    this.clearSubscriptions(client_id);
    delete this.known_pings[client_id];
    if (VERBOSE) {
      log.w('[Binding.pingDidTimeout]', client_id);
    }
    return this.emit('timeout', client_id);
  };

  Binding.prototype.handleMethod = function(client_id, message) {
    var method, ref, response;
    if (VERBOSE) {
      log.d("[Binding.handleMethod]", message);
    }
    if (message.service != null) {

    } else if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
      return response = method.apply(null, slice.call(message.args).concat([(function(_this) {
        return function(err, response) {
          return _this.send(client_id, {
            id: message.id,
            kind: 'response',
            response: response
          });
        };
      })(this)]));
    } else {
      return this.send(client_id, {
        id: message.id,
        kind: 'error',
        error: "Unknown method '" + message.method + "'"
      });
    }
  };

  Binding.prototype.handleSubscribe = function(client_id, subscription) {
    var base, name;
    if (VERBOSE) {
      log.d('[Binding.handleSubscribe]', client_id, subscription);
    }
    subscription.client_id = client_id;
    (base = this.subscriptions)[name = subscription.type] || (base[name] = {});
    return this.subscriptions[subscription.type][subscription.id] = subscription;
  };

  Binding.prototype.handleUnsubscribe = function(client_id, unsubscription) {
    var ref;
    if (VERBOSE) {
      log.d('[Binding.handleUnsubscribe]', client_id, unsubscription);
    }
    return (ref = this.subscriptions[unsubscription.type]) != null ? delete ref[unsubscription.id] : void 0;
  };

  Binding.prototype.send = function(client_id, message, cb) {
    var base;
    if (cb != null) {
      message.id || (message.id = helpers.randomString());
      (base = this.pending_responses)[client_id] || (base[client_id] = {});
      this.pending_responses[client_id][message.id] = cb;
    }
    return this.socket.send([client_id, JSON.stringify(message)]);
  };

  Binding.prototype.method = function() {
    var args, cb, client_id, i, method;
    client_id = arguments[0], method = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    return this.send(client_id, {
      kind: 'method',
      method: method,
      args: args
    }, function(message) {
      return cb(message.error, message.response, message);
    });
  };

  Binding.prototype.subscribe = function() {
    var args, cb, client_id, i, type;
    client_id = arguments[0], type = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    return this.send(client_id, {
      kind: 'subscribe',
      type: type,
      args: args
    }, function(message) {
      return cb(message.error || message.event, message);
    });
  };

  Binding.prototype.unsubscribe = function(client_id, type, id, cb) {
    return this.send(client_id, {
      kind: 'unsubscribe',
      type: type,
      id: id
    });
  };

  Binding.prototype.publish = function(type, event) {
    var client_id, i, id, len, ref, results, subscription, subscriptions;
    subscriptions = this.subscriptions[type];
    ref = helpers.values(subscriptions);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      subscription = ref[i];
      id = subscription.id, client_id = subscription.client_id;
      results.push(this.send(client_id, {
        id: id,
        type: type,
        event: event
      }));
    }
    return results;
  };

  return Binding;

})(EventEmitter);
