// Generated by CoffeeScript 2.0.0-beta4
var Binding, DEFAULT_HOST, DEFAULT_PROTO, EventEmitter, MAX_BIND_RETRIES, VERBOSE, helpers, log, util, zmq,
  slice = [].slice;

zmq = require('zmq');

util = require('util');

({EventEmitter} = require('events'));

helpers = require('./helpers');

({log} = helpers);

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

DEFAULT_HOST = process.env.SOMATA_HOST || '127.0.0.1';

MAX_BIND_RETRIES = 5;

module.exports = Binding = (function() {
  class Binding extends EventEmitter {
    constructor(options = {}) {
      super();
      Object.assign(this, options);
      this.id || (this.id = helpers.randomString());
      this.proto || (this.proto = DEFAULT_PROTO);
      this.host || (this.host = DEFAULT_HOST);
      if (this.proto !== 'ipc') {
        this.port || (this.port = helpers.randomPort());
      }
      this.should_retry = options.port == null; // Retry with random ports if not specified
      this.tryBind();
    }

    emitNext(...args) {
      return process.nextTick(() => {
        return this.emit(...args);
      });
    }

    // Binding
    // --------------------------------------------------------------------------
    tryBind(n_retried = 0) {
      var err;
      try {
        this.address = helpers.makeAddress(this.proto, this.host, this.port);
        if (VERBOSE) {
          log.d(`[Binding.tryBind] Attempting to bind on ${this.address}...`);
        }
        this.socket = zmq.socket('router');
        this.socket.bindSync(this.address);
        return this.didBind();
      } catch (error) {
        err = error;
        log.e(`[Binding.tryBind] Failed to bind on ${this.address}`, err);
        if (!this.should_retry) {
          return process.exit();
        } else if (n_retried < MAX_BIND_RETRIES) {
          log.w("[Binding.tryBind] Retrying...");
          this.port = helpers.randomPort();
          return setTimeout(() => {
            return this.tryBind(n_retried + 1);
          }, 1000);
        } else {
          log.e("[Binding.tryBind] Retried too many times.");
          return process.exit();
        }
      }
    }

    didBind() {
      if (VERBOSE) {
        // Announce that it did bind
        log.i(`[Binding.didBind] Socket ${this.id} bound to ${this.address}`);
      }
      this.emitNext('bind');
      // Start handling messages
      this.socket.on('message', (client_id, message_json) => {
        return this.handleMessage(client_id.toString(), JSON.parse(message_json));
      });
      // Subscribe to default message kinds
      this.on('ping', this.handlePing.bind(this));
      this.on('method', this.handleMethod.bind(this));
      this.on('subscribe', this.handleSubscribe.bind(this));
      return this.on('unsubscribe', this.handleUnsubscribe.bind(this));
    }

    // Incoming messages (from a Connection)
    // --------------------------------------------------------------------------
    handleMessage(client_id, message) {
      var cb, ref;
      if (VERBOSE > 1) {
        log.d(`[Binding.handleMessage] <${client_id}> ${helpers.summarizeMessage(message)}`);
      }
      if (cb = (ref = this.pending_responses[client_id]) != null ? ref[message.id] : void 0) {
        return cb(message);
      } else {
        return this.emit(message.kind, client_id, message);
      }
    }

    handlePing(client_id, message) {
      var pong;
      if (message.ping === 'hello' || (this.known_pings[message.id] == null)) {
        this.known_pings[message.id] = true;
        this.emitNext('connected', client_id);
        pong = 'welcome';
      } else {
        pong = 'pong';
      }
      this.setPingTimeout(client_id);
      return this.send(client_id, {
        id: message.id,
        kind: 'pong',
        pong
      });
    }

    setPingTimeout(client_id) {
      var pingDidTimeout;
      clearTimeout(this.ping_timeouts[client_id]);
      pingDidTimeout = this.pingDidTimeout.bind(this, client_id);
      return this.ping_timeouts[client_id] = setTimeout(pingDidTimeout, 2500);
    }

    clearSubscriptions(client_id) {
      var ref, results, subscription, subscription_id, subscription_type, subscriptions;
      ref = this.subscriptions;
      results = [];
      for (subscription_type in ref) {
        subscriptions = ref[subscription_type];
        results.push((function() {
          var ref1, results1;
          results1 = [];
          for (subscription_id in subscriptions) {
            subscription = subscriptions[subscription_id];
            if (subscription.client_id === client_id) {
              delete this.subscriptions[subscription_type][subscription_id];
              results1.push((ref1 = this.pending_responses[client_id]) != null ? delete ref1[subscription_id] : void 0);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    pingDidTimeout(client_id) {
      this.clearSubscriptions(client_id);
      delete this.known_pings[client_id];
      if (VERBOSE) {
        log.w('[Binding.pingDidTimeout]', client_id);
      }
      return this.emit('timeout', client_id);
    }

    handleMethod(client_id, message) {
      var method, ref, response;
      if (VERBOSE) {
        log.d("[Binding.handleMethod]", message);
      }
      if (message.service != null) {

      // Ignore as it was meant for a service
      } else if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
        return response = method(...message.args, (err, response) => {
          return this.send(client_id, {
            id: message.id,
            kind: 'response',
            response
          });
        });
      } else {
        return this.send(client_id, {
          id: message.id,
          kind: 'error',
          error: `Unknown method '${message.method}'`
        });
      }
    }

    handleSubscribe(client_id, subscription) {
      var base, name;
      if (VERBOSE) {
        log.d('[Binding.handleSubscribe]', client_id, subscription);
      }
      subscription.client_id = client_id;
      (base = this.subscriptions)[name = subscription.type] || (base[name] = {});
      return this.subscriptions[subscription.type][subscription.id] = subscription;
    }

    handleUnsubscribe(client_id, unsubscription) {
      var ref;
      if (VERBOSE) {
        log.d('[Binding.handleUnsubscribe]', client_id, unsubscription);
      }
      return (ref = this.subscriptions[unsubscription.type]) != null ? delete ref[unsubscription.id] : void 0;
    }

    // Outgoing messages
    // --------------------------------------------------------------------------
    send(client_id, message, cb) {
      var base;
      if (cb != null) {
        message.id || (message.id = helpers.randomString());
        (base = this.pending_responses)[client_id] || (base[client_id] = {});
        this.pending_responses[client_id][message.id] = cb;
      }
      return this.socket.send([client_id, JSON.stringify(message)]);
    }

    method(client_id, method, ...args) {
      var cb, i, ref;
      ref = args, args = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), cb = ref[i++];
      return this.send(client_id, {
        kind: 'method',
        method,
        args
      }, function(message) {
        return cb(message.error, message.response, message);
      });
    }

    subscribe(client_id, type, ...args) {
      var cb, i, ref;
      ref = args, args = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), cb = ref[i++];
      return this.send(client_id, {
        kind: 'subscribe',
        type,
        args
      }, function(message) {
        return cb(message.error || message.event, message);
      });
    }

    unsubscribe(client_id, type, id, cb) {
      return this.send(client_id, {
        kind: 'unsubscribe',
        type,
        id
      });
    }

    publish(type, event) {
      var client_id, i, id, len, ref, results, subscription, subscriptions;
      subscriptions = this.subscriptions[type];
      ref = helpers.values(subscriptions);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        subscription = ref[i];
        ({id, client_id} = subscription);
        results.push(this.send(client_id, {id, type, event}));
      }
      return results;
    }

  };

  Binding.prototype.pending_responses = {};

  Binding.prototype.subscriptions = {};

  Binding.prototype.known_pings = {};

  Binding.prototype.ping_timeouts = {};

  return Binding;

})();
