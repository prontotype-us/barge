// Generated by CoffeeScript 2.3.2
var Activator, Client, DEFAULT_CONFIG, DEFAULT_REQUEST, DEFAULT_SUBSCRIBE, DNS_SUFFIX, REQUEST, SUBSCRIBE, Subscription, THROW_ORIGINAL, WS, axios, debug, interpretConnectionError, reverse, uuid;

axios = require('axios');

WS = require('ws');

uuid = require('uuid');

Activator = require('./activator');

Subscription = require('./subscription');

debug = require('debug')('somata:client');

({reverse} = require('./helpers'));

// TODO: Check environment variables are valid
DEFAULT_REQUEST = 'ws'; // 'post'

DEFAULT_SUBSCRIBE = 'ws';

REQUEST = process.env.SOMATA_REQUEST || DEFAULT_REQUEST;

SUBSCRIBE = process.env.SOMATA_SUBSCRIBE || DEFAULT_SUBSCRIBE;

THROW_ORIGINAL = process.env.SOMATA_THROW_ORIGINAL || false;

DEFAULT_CONFIG = {
  timeout: 100
};

DNS_SUFFIX = process.env.SOMATA_DNS_SUFFIX || '';

interpretConnectionError = function(service, base_domain, err) {
  var error, ref, ref1;
  // Don't attempt to interpret error
  if (THROW_ORIGINAL) {
    throw err;
  }
  // Error response from service
  if (error = (ref = err.response) != null ? (ref1 = ref.data) != null ? ref1.error : void 0 : void 0) {
    throw error;
  // Service not found (DNS error)
  } else if (err.code === 'ENOTFOUND') {
    throw `Could not resolve ${base_domain} (is the DNS suffix '${DNS_SUFFIX}' correct?)`;
  // Connection refused (found but not mounted)
  } else if (err.code === 'ECONNREFUSED') {
    throw `Could not connect to service ${service}, is it running?`;
  // Connection aborted (timeout)
  } else if (err.code === 'ECONNABORTED') {
    throw `Request to service ${service} timed out`;
  // Generic HTTP error
  } else if ((err.request != null) && (err.response != null)) {
    throw `Request to ${err.config.url} failed with status ${err.response.status}: ${err.response.statusText}`;
  } else {
    // Unknown error (TODO: handle more specific errors)
    console.log('[err.message]', err.message);
    throw err;
  }
};

module.exports = Client = class Client {
  constructor(service1, config1 = DEFAULT_CONFIG) {
    var deprecated_service;
    // Depending if the incoming message is a response or an event it will
    // either call the response promise or the emit on the subscription.
    this.onWsMessage = this.onWsMessage.bind(this);
    this.onWsClose = this.onWsClose.bind(this);
    this.service = service1;
    this.config = config1;
    if (this.service.match(':')) {
      deprecated_service = this.service;
      this.service = reverse(this.service.split(':')).join('.');
      debug(`Warning: Deprecated service identifier ${deprecated_service} updated to ${this.service}`);
    }
    this.ws_activator = new Activator(this.activateWs.bind(this));
  }

  baseUrl() {
    if (DNS_SUFFIX != null ? DNS_SUFFIX.length : void 0) {
      return [this.service, DNS_SUFFIX].join('.');
    } else {
      return this.service;
    }
  }

  requestUrl(method) {
    return `http://${this.baseUrl()}/${method}.json`;
  }

  websocketUrl() {
    return `ws://${this.baseUrl()}/ws`;
  }

  // Generic requests and subscriptions
  // --------------------------------------------------------------------------

  // Depending on the SOMATA_REQUEST environment variable, a request will use
  // either a HTTP POST or Websocket
  request(method, ...args) {
    if (REQUEST === 'post') {
      return this.postRequest(method, ...args);
    } else if (REQUEST === 'ws') {
      return this.wsRequest(method, ...args);
    }
  }

  // Currently only Websocket subscriptions are supported
  subscribe(event, ...args) {
    if (SUBSCRIBE === 'ws') {
      return this.wsSubscribe(event, ...args);
    }
  }

  // HTTP requests
  // ------------------------------------------------------------------------------
  async postRequest(method, ...args) {
    var config, err, id, message, response, url;
    url = this.requestUrl(method);
    id = uuid();
    message = {id, method, args};
    config = {
      timeout: this.config.timeout
    };
    debug('[postRequest]', message);
    try {
      response = (await axios.post(url, message, config));
      return response.data.response;
    } catch (error1) {
      err = error1;
      return interpretConnectionError(this.service, this.baseUrl(), err);
    }
  }

  // Websocket requests and subscriptions
  // --------------------------------------------------------------------------
  // TODO: Purge completed and expired requests
  // TODO: Purge and error-out (and re-send?) requests after a disconnect
  // TODO: Subscriptions

  // To implement request/reply logic with websocket messages, we keep track of
  // @ws_requests which maps each request message ID to a Promise. A response
  // with a matching message ID will resolve that promise.
  wsRequest(method, ...args) {
    var id;
    id = uuid();
    return new Promise(async(resolve, reject) => {
      var err;
      try {
        await this.sendWsMessage({id, method, args});
      } catch (error1) {
        err = error1;
        reject(err);
      }
      return this.ws_requests[id] = [resolve, reject];
    });
  }

  async sendWsMessage(message) {
    var err, message_json;
    debug('[sendWsMessage]', message);
    try {
      await this.ws_activator.isActive();
    } catch (error1) {
      err = error1;
      interpretConnectionError(this.service, this.baseUrl(), err);
    }
    message_json = JSON.stringify(message);
    return this.ws.send(message_json);
  }

  // For subscriptions, similar to requests, we keep track of @ws_subscriptions
  // mapping each subscription ID to a Promise.
  async wsSubscribe(event, ...args) {
    var id, subscription;
    id = uuid();
    await this.sendWsMessage({id, event, args});
    subscription = new Subscription;
    this.ws_subscriptions[id] = subscription;
    return subscription;
  }

  onWsMessage(message_json) {
    var _, error, event, id, message, pending_request, pending_subscription, response;
    message = JSON.parse(message_json);
    ({id, response, event, error} = message);
    if (response) {
      if ([pending_request, _] = this.ws_requests[id]) {
        return pending_request(message.response);
      } else {
        return debug(`Warning: No pending request for message ${id}`);
      }
    } else if (event) {
      if (pending_subscription = this.ws_subscriptions[id]) {
        return pending_subscription.emit('event', ...message.args);
      } else {
        return debug(`Warning: No pending subscription for message ${id}`);
      }
    } else {
      return console.log('[Unknown message]', message);
    }
  }

  // Websocket helper methods
  // --------------------------------------------------------------------------
  activateWs() {
    this.ws_requests = {};
    this.ws_subscriptions = {};
    this.ws = new WS(this.websocketUrl());
    this.ws.on('message', this.onWsMessage);
    this.ws.on('close', this.onWsClose);
    return new Promise((resolve, reject) => {
      this.ws.on('open', function() {
        return resolve(true);
      });
      return this.ws.on('error', function(err) {
        return reject(err);
      });
    });
  }

  onWsClose() {
    debug('[onWsClose]');
    return this.ws_activator.deactivate();
  }

};
