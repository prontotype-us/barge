// Generated by CoffeeScript 2.4.1
var Activator, Client, DNS_SUFFIX, REQUEST, SUBSCRIBE, Subscription, THROW_ORIGINAL, TIMEOUT, WS, axios, debug, errorToObj, fromPromise, interpretConnectionError, reverse, uuid,
  splice = [].splice;

axios = require('axios');

WS = require('ws');

uuid = require('uuid');

Activator = require('./activator');

Subscription = require('./subscription');

debug = require('debug')('somata:client');

({reverse, errorToObj, fromPromise} = require('./helpers'));

// TODO: Check environment variables are valid
REQUEST = process.env.SOMATA_REQUEST || 'ws';

SUBSCRIBE = process.env.SOMATA_SUBSCRIBE || 'ws';

THROW_ORIGINAL = process.env.SOMATA_THROW_ORIGINAL || false;

TIMEOUT = process.env.SOMATA_TIMEOUT || 3000;

DNS_SUFFIX = process.env.SOMATA_DNS_SUFFIX || '';

interpretConnectionError = function(service, base_domain, err, prefix = '') {
  var error, message, ref, ref1;
  // Don't attempt to interpret error if using THROW_ORIGINAL passthrough
  if (THROW_ORIGINAL) {
    throw err;
  }
  // Error response from service
  if (error = (ref = err.response) != null ? (ref1 = ref.data) != null ? ref1.error : void 0 : void 0) {
    if (typeof error === 'string') {
      message = `${prefix} ${error}`;
      throw message.trim();
    } else {
      throw error;
    }
  // Service not found (DNS error)
  } else if (err.code === 'ENOTFOUND') {
    message = `${prefix} Could not resolve ${base_domain} (is the DNS suffix '${DNS_SUFFIX}' correct?)`;
    throw message.trim();
  // Connection refused (found but not mounted)
  } else if (err.code === 'ECONNREFUSED') {
    message = `${prefix} Could not connect to service ${service}, is it running?`;
    throw message.trim();
  // Connection aborted (timeout)
  } else if (err.code === 'ECONNABORTED') {
    message = `${prefix} Request to service ${service} timed out`;
    throw message.trim();
  // Generic HTTP error
  } else if ((err.request != null) && (err.response != null)) {
    throw `${prefix} Request to ${err.config.url} failed with status ${err.response.status}: ${err.response.statusText}`;
    throw message.trim();
  } else {
    // Unknown error (TODO: handle more specific errors)
    console.error('[err.message]', err.message);
    err = errorToObj(err);
    if (err.message != null) {
      err.message = `${prefix} ${err.message}`.trim();
    }
    throw err;
  }
};

module.exports = Client = class Client {
  constructor(service1) {
    var deprecated_service;
    // Depending if the incoming message is a response or an event it will
    // either call the response promise or the emit on the subscription.
    this.onWsMessage = this.onWsMessage.bind(this);
    this.onWsClose = this.onWsClose.bind(this);
    this.service = service1;
    if (this.service.match(':')) {
      deprecated_service = this.service;
      this.service = reverse(this.service.split(':')).join('.');
      debug(`Warning: Deprecated service identifier ${deprecated_service} updated to ${this.service}`);
    }
    this.ws_activator = new Activator(this.activateWs.bind(this));
  }

  baseUrl() {
    if (DNS_SUFFIX != null ? DNS_SUFFIX.length : void 0) {
      return [this.service, DNS_SUFFIX].join('.');
    } else {
      return this.service;
    }
  }

  requestUrl(method) {
    return `http://${this.baseUrl()}/${method}.json`;
  }

  websocketUrl() {
    return `ws://${this.baseUrl()}/ws`;
  }

  // Generic requests and subscriptions
  // --------------------------------------------------------------------------

  // Depending on the SOMATA_REQUEST environment variable, a request will use
  // either a HTTP POST or Websocket
  request(method, ...args) {
    if (REQUEST === 'post') {
      return this.postRequest(method, ...args);
    } else if (REQUEST === 'ws') {
      return this.wsRequest(method, ...args);
    }
  }

  requestCb(method, ...args) {
    var cb, ref;
    ref = args, [...args] = ref, [cb] = splice.call(args, -1);
    return fromPromise(this.request.bind(this, method, ...args), cb);
  }

  // Currently only Websocket subscriptions are supported
  subscribe(event, ...args) {
    if (SUBSCRIBE === 'ws') {
      return this.wsSubscribe(event, ...args);
    } else {
      return console.error(`Can't subscribe with ${SUBSCRIBE}`);
    }
  }

  // HTTP requests
  // ------------------------------------------------------------------------------
  async postRequest(method, ...args) {
    var config, err, id, message, response, url;
    url = this.requestUrl(method);
    id = uuid();
    message = {id, method, args};
    config = {
      timeout: TIMEOUT
    };
    debug('[postRequest]', this.service, message);
    try {
      response = (await axios.post(url, message, config));
      return response.data.data;
    } catch (error1) {
      err = error1;
      console.error('[wsRequest]', this.service, this.method, err);
      return interpretConnectionError(this.service, this.baseUrl(), err);
    }
  }

  // Websocket requests and subscriptions
  // --------------------------------------------------------------------------
  // TODO: Purge completed and expired requests
  // TODO: Purge and error-out (and re-send?) requests after a disconnect
  // TODO: Subscriptions

  // To implement request/reply logic with websocket messages, we keep track of
  // @ws_requests which maps each request message ID to a Promise. A response
  // with a matching message ID will resolve that promise.
  wsRequest(method, ...args) {
    var id;
    id = uuid();
    return new Promise(async(resolve, reject) => {
      var err;
      try {
        await this.sendWsMessage({id, method, args});
      } catch (error1) {
        err = error1;
        console.error('[wsRequest]', this.service, method, err);
        reject(err);
      }
      this.ws_requests[id] = {resolve, reject};
      return setTimeout(() => {
        delete this.ws_requests[id];
        console.error('[wsRequest] Timed out', this.service, method);
        return reject("Timed out");
      }, TIMEOUT);
    });
  }

  async sendWsMessage(message) {
    var err, message_json;
    debug('[sendWsMessage]', this.service, message);
    try {
      await this.ws_activator.isActive();
    } catch (error1) {
      err = error1;
      interpretConnectionError(this.service, this.baseUrl(), err, `Error connecting to ws://${this.baseUrl()}:`);
    }
    message_json = JSON.stringify(message);
    return this.ws.send(message_json);
  }

  // For subscriptions, similar to requests, we keep track of @ws_subscriptions
  // mapping each subscription ID to a Promise.
  async wsSubscribe(event, ...args) {
    var id, subscription;
    id = uuid();
    await this.sendWsMessage({id, event, args});
    subscription = new Subscription;
    this.ws_subscriptions[id] = subscription;
    return subscription;
  }

  onWsMessage(message_json) {
    var data, id, message, pending_request, pending_subscription, type;
    message = JSON.parse(message_json);
    ({id, type, data} = message);
    switch (type) {
      case 'response':
        if (pending_request = this.ws_requests[id]) {
          return pending_request.resolve(data);
        } else {
          return debug(`Warning: No pending request handler for message ${id}`);
        }
        break;
      case 'event':
        if (pending_subscription = this.ws_subscriptions[id]) {
          return pending_subscription.emit('event', data);
        } else {
          return debug(`Warning: No subscription handler for message ${id}`);
        }
        break;
      case 'error':
        if (pending_request = this.ws_requests[id]) {
          return pending_request.reject(data);
        } else {
          return debug(`Warning: No pending error handler for message ${id}`);
        }
        break;
      default:
        return console.error(`Unknown message type ${type}`, message);
    }
  }

  // Websocket helper methods
  // --------------------------------------------------------------------------
  activateWs() {
    this.ws_requests = {};
    this.ws_subscriptions = {};
    this.ws = new WS(this.websocketUrl());
    this.ws.on('message', this.onWsMessage);
    this.ws.on('close', this.onWsClose);
    return new Promise((resolve, reject) => {
      this.ws.on('open', function() {
        return resolve(true);
      });
      return this.ws.on('error', function(err) {
        return reject(err);
      });
    });
  }

  onWsClose() {
    debug('[onWsClose]', this.service);
    return this.ws_activator.deactivate();
  }

};
