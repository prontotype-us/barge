// Generated by CoffeeScript 2.0.0-beta4
var CONNECTION_LINGER_MS, CONNECTION_RETRY_MS, Client, Connection, EventEmitter, REGISTRY_HOST, REGISTRY_PORT, REGISTRY_PROTO, VERBOSE, emitters, helpers, log,
  slice = [].slice;

Connection = require('./connection');

({EventEmitter} = require('events'));

helpers = require('./helpers');

({log} = helpers);

emitters = require('./events');

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

REGISTRY_PROTO = process.env.SOMATA_REGISTRY_PROTO || 'tcp';

REGISTRY_HOST = process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

REGISTRY_PORT = process.env.SOMATA_REGISTRY_PORT || 8420;

CONNECTION_LINGER_MS = 1500;

CONNECTION_RETRY_MS = 2500;

Client = (function() {
  class Client extends EventEmitter {
    constructor(options = {}) {
      super();
      Object.assign(this, options);
      this.connectToRegistry();
    }

    connectToRegistry() {
      this.registry_connection = new Connection({
        proto: this.registry_proto || REGISTRY_PROTO,
        host: this.registry_host || REGISTRY_HOST,
        port: this.registry_port || REGISTRY_PORT,
        service: {
          id: 'registry~0',
          name: 'registry'
        }
      });
      return this.registry_connection.on('connect', this.registryConnected.bind(this));
    }

    registryConnected() {
      this.connected_to_registry = true;
      this.registry_connection.subscribe('register', this.registeredService.bind(this));
      this.registry_connection.subscribe('deregister', this.deregisteredService.bind(this));
      return this.emit('registry_connected', true);
    }

    registeredService(new_service) {
      if (VERBOSE > 1) {
        return log.d('[Client.registry_connection.register]', new_service);
      }
    }

    deregisteredService(old_service) {
      if (VERBOSE > 1) {
        log.d('[Client.registry_connection.deregister]', old_service);
      }
      return delete this.service_connections[old_service.name];
    }

    // TODO: Remove existing subscriptions

    // Main API of remote and subscribe
    // --------------------------------------------------------------------------
    remote(service, method, ...args) {
      var cb, i, ref;
      ref = args, args = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), cb = ref[i++];
      if (VERBOSE > 1) {
        log.d(`[Client.remote] ${service}.${method}(${args})`);
      }
      return this.getConnection(service, (err, connection) => {
        if (connection != null) {
          return connection.method(method, ...args, cb);
        } else {
          log.e(`[Client.remote] No connection to ${service}`);
          return cb(`No connection to ${service}`);
        }
      });
    }

    subscribe(service, type, ...args) {
      var cb, i, id, ref, service_name, subscription;
      ref = args, args = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), cb = ref[i++];
      if (arguments.length === 1) { // options containing cb
        subscription = arguments[0];
        ({id, service, type, args, cb} = subscription);
      }
      id || (id = helpers.randomString());
      if (!this.connected_to_registry) {
        setTimeout((() => {
          return this.subscribe({id, service, type, args, cb});
        }), 500);
        return;
      }
      if (typeof service === 'object') {
        service_name = service.name;
      } else {
        service_name = service.split('~')[0];
      }
      return this.getConnection(service_name, (err, connection) => {
        var _subscribe;
        if (connection != null) {
          if (VERBOSE) {
            log.i('[Client.subscribe]', {service, type, args});
          }
          subscription = {
            id,
            service: connection.service.id,
            kind: 'subscribe',
            type,
            args
          };
          if (connection.connected) {
            this.sendSubscription(connection, subscription, cb);
          } else {
            connection.on('connect', () => {
              return this.sendSubscription(connection, subscription, cb);
            });
          }
          return connection.on('timeout', () => {
            if (VERBOSE) {
              log.e(`[Client.subscribe.connection.on timeout] ${helpers.summarizeConnection(connection)}`);
            }
            delete this.service_subscriptions[connection.service.id];
            return setTimeout(() => {
              return this.subscribe(service, type, ...args, cb);
            }, 500);
          });
        } else {
          log.e('[Client.subscribe] No connection');
          _subscribe = () => {
            return this.subscribe(service, type, ...args, cb);
          };
          return setTimeout(_subscribe, 1500);
        }
      });
    }

    unsubscribe(subscription_id) {
      var subscription;
      if (subscription = this.subscriptions[subscription_id]) {
        return this.getConnection(subscription.service, function(err, connection) {
          if (connection != null) {
            if (VERBOSE) {
              log.w('[Client.unsubscribe]', subscription_id);
            }
            return connection.unsubscribe(subscription.type, subscription.id);
          }
        });
      }
    }

    sendSubscription(connection, subscription, cb) {
      var base, eventCb, name;
      eventCb = function(message) {
        return cb(message.error || message.event, message);
      };
      delete subscription.cb;
      connection.send(subscription, eventCb);
      subscription.cb = cb;
      (base = this.service_subscriptions)[name = subscription.service.id] || (base[name] = []);
      this.service_subscriptions[subscription.service.id].push(subscription);
      return this.subscriptions[subscription.id] = subscription;
    }

    // Connections to Services
    // --------------------------------------------------------------------------
    getService(service_name, cb) {
      return this.registry_connection.method('getService', service_name, cb);
    }

    getConnection(service_id, cb) {
      var connection, service_name;
      service_name = service_id.split('~')[0];
      if (service_name === 'registry') {
        return cb(null, this.registry_connection);
      } else if (connection = this.service_connections[service_name]) {
        return cb(null, connection);
      } else {
        return this.getService(service_name, (err, service) => {
          if (err || (service == null)) {
            return cb(err);
          }
          connection = new Connection({
            host: service.host,
            port: service.port,
            service: service
          });
          this.service_connections[service_name] = connection;
          connection.on('timeout', () => {
            delete this.service_connections[service_name];
            return connection.close();
          });
          return cb(null, connection);
        });
      }
    }

    closeConnections() {
      var connection, ref, service_name;
      ref = this.service_connections;
      for (service_name in ref) {
        connection = ref[service_name];
        connection.close();
      }
      return this.registry_connection.close();
    }

  };

  Client.prototype.subscriptions = {};

  Client.prototype.service_subscriptions = {};

  Client.prototype.service_connections = {};

  return Client;

})();

module.exports = Client;
