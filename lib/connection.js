// Generated by CoffeeScript 1.12.4
var Connection, DEFAULT_CONNECT, DEFAULT_PROTO, EventEmitter, PING_INTERVAL, VERBOSE, _, helpers, log, util, zmq,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

zmq = require('zmq');

util = require('util');

_ = require('underscore');

EventEmitter = require('events').EventEmitter;

helpers = require('./helpers');

log = helpers.log;

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

DEFAULT_CONNECT = process.env.SOMATA_CONNECT || process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

PING_INTERVAL = parseInt(process.env.SOMATA_PING_INTERVAL) || 2000;

module.exports = Connection = (function(superClass) {
  extend(Connection, superClass);

  Connection.prototype.pending_responses = {};

  Connection.prototype.subscriptions = {};

  function Connection(options) {
    if (options == null) {
      options = {};
    }
    Object.assign(this, options);
    this.id || (this.id = helpers.randomString());
    this.proto || (this.proto = DEFAULT_PROTO);
    this.host || (this.host = DEFAULT_CONNECT);
    this.address = helpers.makeAddress(this.proto, this.host, this.port);
    this.connect();
  }

  Connection.prototype.connect = function() {
    this.socket = zmq.socket('dealer');
    this.socket.identity = this.id;
    this.socket.connect(this.address);
    this.socket.on('message', (function(_this) {
      return function(message_json) {
        return _this.handleMessage(JSON.parse(message_json));
      };
    })(this));
    if (VERBOSE) {
      log.i("[Connection.connect] " + (helpers.summarizeConnection(this)) + " connected to " + this.address);
    }
    return this.connected();
  };

  Connection.prototype.connected = function() {
    this.on('method', this.handleMethod.bind(this));
    this.on('subscribe', this.handleSubscribe.bind(this));
    return process.nextTick((function(_this) {
      return function() {
        return _this.sendPing();
      };
    })(this));
  };

  Connection.prototype.handleMessage = function(message) {
    var on_response;
    if (VERBOSE > 1) {
      log.d("[Connection.handleMessage] " + (helpers.summarizeConnection(this)) + " " + (helpers.summarizeMessage(message)));
    }
    if (on_response = this.pending_responses[message.id]) {
      if (on_response.timeout != null) {
        clearTimeout(on_response.timeout);
      }
      if (on_response.once) {
        delete this.pending_responses[message.id];
      }
      return on_response(message);
    } else if (message.kind != null) {
      return this.emit(message.kind, message);
    } else {
      if (VERBOSE) {
        return log.w('[handleMessage] No pending response for ' + message.id);
      }
    }
  };

  Connection.prototype.handleMethod = function(message) {
    var method, ref, response;
    if (VERBOSE) {
      log.d("[Connection.on method]", message);
    }
    if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
      return response = method.apply(null, slice.call(message.args).concat([(function(_this) {
        return function(err, response) {
          return _this.send({
            id: message.id,
            kind: 'response',
            response: response
          });
        };
      })(this)]));
    } else {
      return this.send({
        id: message.id,
        kind: 'error',
        error: "Unknown method"
      });
    }
  };

  Connection.prototype.handleSubscribe = function(subscription) {
    var base, name;
    if (VERBOSE) {
      log.d('[Connection.on subscribe]', subscription);
    }
    (base = this.subscriptions)[name = subscription.type] || (base[name] = {});
    return this.subscriptions[subscription.type][subscription.id] = subscription;
  };

  Connection.prototype.handleUnsubscribe = function(unsubscription) {};

  Connection.prototype.send = function(message, cb) {
    var ref;
    message.id || (message.id = helpers.randomString(16));
    message.service || (message.service = (ref = this.service) != null ? ref.id : void 0);
    if (cb != null) {
      this.pending_responses[message.id] = cb;
    }
    this.socket.send(JSON.stringify(message));
    return message;
  };

  Connection.prototype.method = function() {
    var args, cb, i, method;
    method = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
    if (cb != null) {
      cb.once = true;
    }
    return this.send({
      kind: 'method',
      method: method,
      args: args
    }, function(message) {
      return cb(message.error, message.response, message);
    });
  };

  Connection.prototype.subscribe = function() {
    var args, cb, i, type;
    type = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
    return this.send({
      kind: 'subscribe',
      type: type,
      args: args
    }, function(message) {
      return cb(message.error || message.event, message);
    });
  };

  Connection.prototype.unsubscribe = function(type, id) {
    return this.send({
      kind: 'unsubscribe',
      type: type,
      id: id
    });
  };

  Connection.prototype.publish = function(type, event) {
    var i, id, len, ref, results, subscription, subscriptions;
    subscriptions = this.subscriptions[type];
    ref = helpers.values(subscriptions);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      subscription = ref[i];
      id = subscription.id;
      results.push(this.send({
        id: id,
        type: type,
        event: event
      }));
    }
    return results;
  };

  Connection.prototype.last_ping = null;

  Connection.prototype.last_pong = null;

  Connection.prototype.sendPing = function() {
    var message, ping, ref, ref1;
    if (this.service.heartbeat === 0) {
      return;
    }
    this.pongTimeoutTimeout = setTimeout(this.pongDidTimeout.bind(this), this.service.heartbeat || PING_INTERVAL);
    ping = this.last_pong != null ? 'ping' : 'hello';
    message = {
      id: (ref = this.last_ping) != null ? ref.id : void 0,
      kind: 'ping',
      ping: ping,
      service: (ref1 = this.service) != null ? ref1.id : void 0
    };
    return this.last_ping = this.send(message, this.handlePong.bind(this));
  };

  Connection.prototype.handlePong = function(message) {
    var is_new;
    if (this.closed) {
      if (VERBOSE) {
        log.e('[handlePong] Connection is closed');
      }
      return;
    }
    if (message.pong === 'welcome') {
      if (VERBOSE) {
        log.i("[Connection.handlePong] " + (helpers.summarizeConnection(this)) + " New ping response");
      }
      is_new = this.last_pong == null;
      this.clearSubscriptions();
      this.connected = true;
      this.emit('connect', is_new);
      this.last_pong = new Date();
    } else {
      if (VERBOSE > 2) {
        log.d("[Connection.handlePong] " + (helpers.summarizeConnection(this)) + " Continuing ping");
      }
      this.last_pong = new Date();
    }
    if (this.service.heartbeat === 0) {
      return;
    }
    clearTimeout(this.pongTimeoutTimeout);
    return this.nextPingTimeout = setTimeout(this.sendPing.bind(this), this.service.heartbeat || PING_INTERVAL);
  };

  Connection.prototype.pongDidTimeout = function() {
    log.e("[Connection.pongDidTimeout] " + (helpers.summarizeConnection(this)));
    delete this.last_ping;
    delete this.last_pong;
    this.clearSubscriptions();
    this.connected = false;
    return this.emit('timeout');
  };

  Connection.prototype.clearSubscriptions = function() {
    var ref, results, subscription, subscription_id, subscription_type, subscriptions;
    ref = this.subscriptions;
    results = [];
    for (subscription_type in ref) {
      subscriptions = ref[subscription_type];
      results.push((function() {
        var results1;
        results1 = [];
        for (subscription_id in subscriptions) {
          subscription = subscriptions[subscription_id];
          delete this.subscriptions[subscription_type][subscription_id];
          results1.push(delete this.pending_responses[subscription_id]);
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  Connection.prototype.close = function() {
    if (VERBOSE) {
      log.e("[Connection.close] " + (helpers.summarizeConnection(this)));
    }
    delete this.last_ping;
    delete this.last_pong;
    clearTimeout(this.nextPingTimeout);
    clearTimeout(this.pongTimeoutTimeout);
    this.closed = true;
    return this.socket.close();
  };

  return Connection;

})(EventEmitter);
