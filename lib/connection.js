// Generated by CoffeeScript 2.0.0-beta4
var Connection, DEFAULT_CONNECT, DEFAULT_PROTO, EventEmitter, PING_INTERVAL, VERBOSE, _, helpers, log, util, zmq,
  slice = [].slice;

zmq = require('zmq');

util = require('util');

_ = require('underscore');

({EventEmitter} = require('events'));

helpers = require('./helpers');

({log} = helpers);

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

DEFAULT_CONNECT = process.env.SOMATA_CONNECT || process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

PING_INTERVAL = parseInt(process.env.SOMATA_PING_INTERVAL) || 2000;

module.exports = Connection = (function() {
  class Connection extends EventEmitter {
    // Create a new Somata connection
    // --------------------------------------------------------------------------

    // Accepts an optional `id`, or generates one if none is supplied.

    // Creates a socket address by combining the optional supplied `proto`,
    // `host`, and `port`, and connects to that address.
    constructor(options = {}) {
      super();
      Object.assign(this, options);
      this.id || (this.id = helpers.randomString());
      this.proto || (this.proto = DEFAULT_PROTO);
      this.host || (this.host = DEFAULT_CONNECT);
      this.address = helpers.makeAddress(this.proto, this.host, this.port);
      this.connect();
    }

    // Create and connect the connection socket
    // --------------------------------------------------------------------------

    // Messages sent to the connected socket are handled with `handleMessage`.
    connect() {
      this.socket = zmq.socket('dealer');
      this.socket.identity = this.id;
      this.socket.connect(this.address);
      this.socket.on('message', (message_json) => {
        return this.handleMessage(JSON.parse(message_json));
      });
      if (VERBOSE) {
        log.i(`[Connection.connect] ${helpers.summarizeConnection(this)} connected to ${this.address}`);
      }
      return this.connected();
    }

    connected() {
      this.on('method', this.handleMethod.bind(this));
      this.on('subscribe', this.handleSubscribe.bind(this));
      return process.nextTick(() => {
        return this.sendPing();
      });
    }

    // Incoming messages (from a connected-to Binding)
    // --------------------------------------------------------------------------
    handleMessage(message) {
      var on_response;
      if (VERBOSE > 1) {
        log.d(`[Connection.handleMessage] ${helpers.summarizeConnection(this)} ${helpers.summarizeMessage(message)}`);
      }
      if (on_response = this.pending_responses[message.id]) {
        // Clear timeout if it exists
        if (on_response.timeout != null) {
          clearTimeout(on_response.timeout);
        }
        if (on_response.once) {
          delete this.pending_responses[message.id];
        }
        return on_response(message);
      } else if (message.kind != null) {
        return this.emit(message.kind, message);
      } else {
        if (VERBOSE) {
          return log.w('[handleMessage] No pending response for ' + message.id);
        }
      }
    }

    handleMethod(message) {
      var method, ref, response;
      if (VERBOSE) {
        log.d("[Connection.on method]", message);
      }
      if (method = (ref = this.methods) != null ? ref[message.method] : void 0) {
        return response = method(...message.args, (err, response) => {
          return this.send({
            id: message.id,
            kind: 'response',
            response
          });
        });
      } else {
        return this.send({
          id: message.id,
          kind: 'error',
          error: "Unknown method"
        });
      }
    }

    handleSubscribe(subscription) {
      var base, name;
      if (VERBOSE) {
        log.d('[Connection.on subscribe]', subscription);
      }
      (base = this.subscriptions)[name = subscription.type] || (base[name] = {});
      return this.subscriptions[subscription.type][subscription.id] = subscription;
    }

    handleUnsubscribe(unsubscription) {}

    // TODO

    // Outgoing messages
    // --------------------------------------------------------------------------
    send(message, cb) {
      var ref;
      message.id || (message.id = helpers.randomString(16));
      message.service || (message.service = (ref = this.service) != null ? ref.id : void 0);
      if (cb != null) {
        this.pending_responses[message.id] = cb;
      }
      this.socket.send(JSON.stringify(message));
      return message;
    }

    method(method, ...args) {
      var cb, i, ref;
      ref = args, args = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), cb = ref[i++];
      if (cb != null) {
        cb.once = true;
      }
      return this.send({
        kind: 'method',
        method,
        args
      }, function(message) {
        return cb(message.error, message.response, message);
      });
    }

    subscribe(type, ...args) {
      var cb, i, ref;
      ref = args, args = 2 <= ref.length ? slice.call(ref, 0, i = ref.length - 1) : (i = 0, []), cb = ref[i++];
      return this.send({
        kind: 'subscribe',
        type,
        args
      }, function(message) {
        return cb(message.error || message.event, message);
      });
    }

    unsubscribe(type, id) {
      return this.send({
        kind: 'unsubscribe',
        type,
        id
      });
    }

    publish(type, event) {
      var i, id, len, ref, results, subscription, subscriptions;
      subscriptions = this.subscriptions[type];
      ref = helpers.values(subscriptions);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        subscription = ref[i];
        ({id} = subscription);
        results.push(this.send({id, type, event}));
      }
      return results;
    }

    sendPing() {
      var message, ping, ref, ref1;
      if (this.service.heartbeat === 0) {
        return;
      }
      this.pongTimeoutTimeout = setTimeout(this.pongDidTimeout.bind(this), this.service.heartbeat || PING_INTERVAL);
      ping = this.last_pong != null ? 'ping' : 'hello';
      message = {
        id: (ref = this.last_ping) != null ? ref.id : void 0,
        kind: 'ping',
        ping,
        service: (ref1 = this.service) != null ? ref1.id : void 0
      };
      return this.last_ping = this.send(message, this.handlePong.bind(this));
    }

    handlePong(message) {
      var is_new;
      if (this.closed) {
        if (VERBOSE) {
          log.e('[handlePong] Connection is closed');
        }
        return;
      }
      if (message.pong === 'welcome') {
        if (VERBOSE) {
          log.i(`[Connection.handlePong] ${helpers.summarizeConnection(this)} New ping response`);
        }
        is_new = this.last_pong == null;
        this.clearSubscriptions();
        this.connected = true;
        this.emit('connect', is_new);
        this.last_pong = new Date();
      } else {
        if (VERBOSE > 2) {
          log.d(`[Connection.handlePong] ${helpers.summarizeConnection(this)} Continuing ping`);
        }
        this.last_pong = new Date();
      }
      if (this.service.heartbeat === 0) {
        return;
      }
      clearTimeout(this.pongTimeoutTimeout);
      return this.nextPingTimeout = setTimeout(this.sendPing.bind(this), this.service.heartbeat || PING_INTERVAL);
    }

    pongDidTimeout() {
      log.e(`[Connection.pongDidTimeout] ${helpers.summarizeConnection(this)}`);
      // @nextPingTimeout = setTimeout @sendPing.bind(@), PING_INTERVAL * 2
      delete this.last_ping;
      delete this.last_pong;
      this.clearSubscriptions();
      this.connected = false;
      return this.emit('timeout');
    }

    clearSubscriptions() {
      var ref, results, subscription, subscription_id, subscription_type, subscriptions;
      ref = this.subscriptions;
      results = [];
      for (subscription_type in ref) {
        subscriptions = ref[subscription_type];
        results.push((function() {
          var results1;
          results1 = [];
          for (subscription_id in subscriptions) {
            subscription = subscriptions[subscription_id];
            delete this.subscriptions[subscription_type][subscription_id];
            results1.push(delete this.pending_responses[subscription_id]);
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    close() {
      if (VERBOSE) {
        log.e(`[Connection.close] ${helpers.summarizeConnection(this)}`);
      }
      delete this.last_ping;
      delete this.last_pong;
      clearTimeout(this.nextPingTimeout);
      clearTimeout(this.pongTimeoutTimeout);
      this.closed = true;
      return this.socket.close();
    }

  };

  // Store pending response callbacks
  // --------------------------------------------------------------------------

  // If a message from the connected-to service corresponds to a response
  // callback in this object, the stored callback will be called with that
  // message as its argument.
  Connection.prototype.pending_responses = {};

  Connection.prototype.subscriptions = {};

  // Ping logic, to keep track of the connected-to binding
  // --------------------------------------------------------------------------
  Connection.prototype.last_ping = null;

  Connection.prototype.last_pong = null;

  return Connection;

})();
