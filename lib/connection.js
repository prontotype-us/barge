// Generated by CoffeeScript 1.8.0
var Connection, DEFAULT_CONNECT, DEFAULT_PROTO, EventEmitter, PING_INTERVAL, VERBOSE, helpers, log, util, zmq, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

zmq = require('zmq');

util = require('util');

_ = require('underscore');

EventEmitter = require('events').EventEmitter;

helpers = require('./helpers');

log = helpers.log;

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

DEFAULT_CONNECT = process.env.SOMATA_CONNECT || process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

PING_INTERVAL = parseInt(process.env.SOMATA_PING_INTERVAL) || 2000;

module.exports = Connection = (function(_super) {
  __extends(Connection, _super);

  Connection.prototype.pending_responses = {};

  Connection.prototype.subscriptions = {};

  function Connection(options) {
    if (options == null) {
      options = {};
    }
    Object.assign(this, options);
    this.id || (this.id = helpers.randomString());
    this.proto || (this.proto = DEFAULT_PROTO);
    this.host || (this.host = DEFAULT_CONNECT);
    this.address = helpers.makeAddress(this.proto, this.host, this.port);
    this.connect();
  }

  Connection.prototype.connect = function() {
    this.socket = zmq.socket('dealer');
    this.socket.identity = this.id;
    this.socket.connect(this.address);
    this.socket.on('message', (function(_this) {
      return function(message_json) {
        return _this.handleMessage(JSON.parse(message_json));
      };
    })(this));
    if (VERBOSE) {
      log.i("[Connection.connect] " + (helpers.summarizeConnection(this)) + " connected to " + this.address);
    }
    return this.connected();
  };

  Connection.prototype.connected = function() {
    this.on('method', this.handleMethod.bind(this));
    this.on('subscribe', this.handleSubscribe.bind(this));
    return process.nextTick((function(_this) {
      return function() {
        return _this.sendPing();
      };
    })(this));
  };

  Connection.prototype.handleMessage = function(message) {
    var on_response;
    if (VERBOSE > 1) {
      log.d("[Connection.handleMessage] " + (helpers.summarizeConnection(this)) + " " + (helpers.summarizeMessage(message)));
    }
    if (on_response = this.pending_responses[message.id]) {
      if (on_response.timeout != null) {
        clearTimeout(on_response.timeout);
      }
      if (on_response.once) {
        delete this.pending_responses[message.id];
      }
      return on_response(message);
    } else if (message.kind != null) {
      return this.emit(message.kind, message);
    } else {
      if (VERBOSE) {
        return log.w('[handleMessage] No pending response for ' + message.id);
      }
    }
  };

  Connection.prototype.handleMethod = function(message) {
    var method, response, _ref;
    if (VERBOSE) {
      log.d("[Connection.on method]", message);
    }
    if (method = (_ref = this.methods) != null ? _ref[message.method] : void 0) {
      return response = method.apply(null, __slice.call(message.args).concat([(function(_this) {
        return function(err, response) {
          return _this.send({
            id: message.id,
            kind: 'response',
            response: response
          });
        };
      })(this)]));
    } else {
      return this.send({
        id: message.id,
        kind: 'error',
        error: "Unknown method"
      });
    }
  };

  Connection.prototype.handleSubscribe = function(subscription) {
    var _base, _name;
    if (VERBOSE) {
      log.d('[Connection.on subscribe]', subscription);
    }
    (_base = this.subscriptions)[_name = subscription.type] || (_base[_name] = {});
    return this.subscriptions[subscription.type][subscription.id] = subscription;
  };

  Connection.prototype.handleUnsubscribe = function(unsubscription) {};

  Connection.prototype.send = function(message, cb) {
    var _ref;
    message.id || (message.id = helpers.randomString(16));
    message.service || (message.service = (_ref = this.service) != null ? _ref.id : void 0);
    if (cb != null) {
      this.pending_responses[message.id] = cb;
    }
    this.socket.send(JSON.stringify(message));
    return message;
  };

  Connection.prototype.method = function() {
    var args, cb, method, _i;
    method = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
    if (cb != null) {
      cb.once = true;
    }
    return this.send({
      kind: 'method',
      method: method,
      args: args
    }, function(message) {
      return cb(message.error, message.response, message);
    });
  };

  Connection.prototype.subscribe = function() {
    var args, cb, type, _i;
    type = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
    return this.send({
      kind: 'subscribe',
      type: type,
      args: args
    }, function(message) {
      return cb(message.error || message.event, message);
    });
  };

  Connection.prototype.unsubscribe = function(type, id) {
    return this.send({
      kind: 'unsubscribe',
      type: type,
      id: id
    });
  };

  Connection.prototype.publish = function(type, event) {
    var id, subscription, subscriptions, _i, _len, _ref, _results;
    subscriptions = this.subscriptions[type];
    _ref = helpers.values(subscriptions);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      subscription = _ref[_i];
      id = subscription.id;
      _results.push(this.send({
        id: id,
        type: type,
        event: event
      }));
    }
    return _results;
  };

  Connection.prototype.last_ping = null;

  Connection.prototype.last_pong = null;

  Connection.prototype.sendPing = function() {
    var message, ping, _ref, _ref1;
    if (this.service.heartbeat === 0) {
      return;
    }
    this.pongTimeoutTimeout = setTimeout(this.pongDidTimeout.bind(this), this.service.heartbeat || PING_INTERVAL);
    ping = this.last_pong != null ? 'ping' : 'hello';
    message = {
      id: (_ref = this.last_ping) != null ? _ref.id : void 0,
      kind: 'ping',
      ping: ping,
      service: (_ref1 = this.service) != null ? _ref1.id : void 0
    };
    return this.last_ping = this.send(message, this.handlePong.bind(this));
  };

  Connection.prototype.handlePong = function(message) {
    var is_new;
    if (this.closed) {
      if (VERBOSE) {
        log.e('[handlePong] Connection is closed');
      }
      return;
    }
    if (message.pong === 'welcome') {
      if (VERBOSE) {
        log.i("[Connection.handlePong] " + (helpers.summarizeConnection(this)) + " New ping response");
      }
      is_new = this.last_pong == null;
      this.clearSubscriptions();
      this.connected = true;
      this.emit('connect', is_new);
      this.last_pong = new Date();
    } else {
      if (VERBOSE > 2) {
        log.d("[Connection.handlePong] " + (helpers.summarizeConnection(this)) + " Continuing ping");
      }
      this.last_pong = new Date();
    }
    if (this.service.heartbeat === 0) {
      return;
    }
    clearTimeout(this.pongTimeoutTimeout);
    return this.nextPingTimeout = setTimeout(this.sendPing.bind(this), this.service.heartbeat || PING_INTERVAL);
  };

  Connection.prototype.pongDidTimeout = function() {
    log.e("[Connection.pongDidTimeout] " + (helpers.summarizeConnection(this)));
    delete this.last_ping;
    delete this.last_pong;
    this.clearSubscriptions();
    this.connected = false;
    return this.emit('timeout');
  };

  Connection.prototype.clearSubscriptions = function() {
    var subscription, subscription_id, subscription_type, subscriptions, _ref, _results;
    _ref = this.subscriptions;
    _results = [];
    for (subscription_type in _ref) {
      subscriptions = _ref[subscription_type];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (subscription_id in subscriptions) {
          subscription = subscriptions[subscription_id];
          delete this.subscriptions[subscription_type][subscription_id];
          _results1.push(delete this.pending_responses[subscription_id]);
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Connection.prototype.close = function() {
    if (VERBOSE) {
      log.e("[Connection.close] " + (helpers.summarizeConnection(this)));
    }
    delete this.last_ping;
    delete this.last_pong;
    clearTimeout(this.nextPingTimeout);
    clearTimeout(this.pongTimeoutTimeout);
    this.closed = true;
    return this.socket.close();
  };

  return Connection;

})(EventEmitter);
