// Generated by CoffeeScript 2.4.1
var PORT, Service, debug, errorToObj, express, express_ws, reverse, uuid;

express = require('express');

express_ws = require('express-ws');

uuid = require('uuid');

debug = require('debug')('somata:service');

({reverse, errorToObj} = require('./helpers'));

PORT = process.env.SOMATA_PORT || 8000;

module.exports = Service = class Service {
  constructor(service, methods) {
    var app, deprecated_service;
    this.service = service;
    this.methods = methods;
    if (this.service.match(':')) {
      deprecated_service = this.service;
      this.service = reverse(this.service.split(':')).join('.');
      debug(`Warning: Deprecated service identifier ${deprecated_service} updated to ${this.service}`);
    }
    this.subscriptions = {};
    app = express();
    express_ws(app);
    app.use(express.json({
      limit: '7MB' //, verify: rawBodySaver
    }));
    app.post('/:method.json', this.onPostRequest.bind(this));
    app.ws('/ws', (ws, req) => {
      return ws.on('message', (message_json) => {
        var message;
        message = JSON.parse(message_json);
        if (message.method != null) {
          return this.onWsRequest(ws, message);
        } else if (message.event != null) {
          return this.onWsSubscribe(ws, message);
        }
      });
    });
    app.listen(PORT, function() {
      return debug(`Listening on :${PORT}`);
    });
  }

  // Handing subscriptions
  // --------------------------------------------------------------------------

  // Subscriptions (currently ond only by websockets) are stored in
  // @subscriptions as event -> [{id, sendEvent}]. When an event is published
  // all clients who were subscribed are sent the event.
  onWsSubscribe(ws, message) {
    var args, event, id, sendEvent;
    debug('[onWsSubscribe]', message);
    ({id, event, args} = message);
    // TODO: try/catch
    sendEvent = function(event_message) {
      var event_message_json;
      debug('[sendEvent]', event_message);
      event_message_json = JSON.stringify(event_message);
      return ws.send(event_message_json);
    };
    this.onSubscribe(id, event, args, sendEvent);
    return ws.on('close', this.onUnsubscribe.bind(this, event, args, sendEvent));
  }

  // TODO: Take args into consideration
  onSubscribe(id, event, args, sendEvent) {
    var base;
    (base = this.subscriptions)[event] || (base[event] = []);
    return this.subscriptions[event].push({id, sendEvent});
  }

  onUnsubscribe(event, args, sendEvent) {
    return this.subscriptions[event] = this.subscriptions[event].filter(function(subscribed) {
      return subscribed.sendEvent !== sendEvent;
    });
  }

  publish(event, data) {
    var event_message, i, id, len, ref, ref1, results, sendEvent;
    if ((ref = this.subscriptions[event]) != null ? ref.length : void 0) {
      ref1 = this.subscriptions[event];
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        ({id, sendEvent} = ref1[i]);
        event_message = {
          id,
          type: 'event',
          event,
          data
        };
        results.push(sendEvent(event_message));
      }
      return results;
    }
  }

  // Handling requests
  // --------------------------------------------------------------------------
  async onPostRequest(req, res) {
    var args, err, method, response;
    ({method} = req.params);
    ({args} = req.body);
    debug('[request]', method, args);
    try {
      response = (await this.onMethod(method, args));
      debug('[response]', response);
      res.status(200);
      return res.json({
        type: 'response',
        data: response
      });
    } catch (error) {
      err = error;
      res.status(500);
      if (err instanceof Error) {
        err = errorToObj(err);
      }
      return res.json({
        type: 'error',
        data: err
      });
    }
  }

  async onWsRequest(ws, message) {
    var args, err, error_json, method, response, response_json;
    ({method, args} = message);
    try {
      response = (await this.onMethod(method, args));
      response_json = JSON.stringify({
        id: message.id,
        type: 'response',
        data: response
      });
      return ws.send(response_json);
    } catch (error) {
      err = error;
      if (err instanceof Error) {
        err = errorToObj(err);
      }
      error_json = {
        id: message.id,
        type: 'error',
        data: err
      };
      return ws.send(JSON.stringify(error_json));
    }
  }

  onMethod(method, args = []) {
    debug('[onMethod]', method, args);
    return this.methods[method](...args);
  }

};
