// Generated by CoffeeScript 1.8.0
var Binding, Connection, EventEmitter, REGISTRY_HOST, REGISTRY_PORT, REGISTRY_PROTO, SERVICE_HOST, SERVICE_PORT, SERVICE_PROTO, SomataService, VERBOSE, emitters, helpers, log, usage, util, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

util = require('util');

_ = require('underscore');

EventEmitter = require('events').EventEmitter;

usage = require('usage');

emitters = require('./events');

Binding = require('./binding');

Connection = require('./connection');

helpers = require('./helpers');

log = helpers.log;

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

REGISTRY_PROTO = process.env.SOMATA_REGISTRY_PROTO || 'tcp';

REGISTRY_HOST = process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

REGISTRY_PORT = process.env.SOMATA_REGISTRY_PORT || 8420;

SERVICE_PROTO = process.env.SOMATA_SERVICE_PROTO;

SERVICE_HOST = process.env.SOMATA_SERVICE_HOST;

SERVICE_PORT = process.env.SOMATA_SERVICE_PORT;

module.exports = SomataService = (function(_super) {
  __extends(SomataService, _super);

  function SomataService(name, methods, options) {
    var _base, _base1, _base2;
    this.name = name;
    this.methods = methods != null ? methods : {};
    if (options == null) {
      options = {};
    }
    this.id = this.name + '~' + helpers.randomString();
    Object.assign(this, options);
    this.binding_options || (this.binding_options = {});
    (_base = this.binding_options).proto || (_base.proto = SERVICE_PROTO);
    (_base1 = this.binding_options).host || (_base1.host = SERVICE_HOST);
    (_base2 = this.binding_options).port || (_base2.port = SERVICE_PORT);
    this.bindRPC((function(_this) {
      return function() {
        return _this.register();
      };
    })(this));
    emitters.exit.onExit((function(_this) {
      return function(cb) {
        return _this.deregister(cb);
      };
    })(this));
  }

  SomataService.prototype.bindRPC = function(cb) {
    this.binding = new Binding(this.binding_options);
    this.binding.on('bind', cb);
    this.binding.on('method', this.handleMethod.bind(this));
    this.binding.on('subscribe', this.handleSubscribe.bind(this));
    return this.binding.on('unsubscribe', this.handleUnsubscribe.bind(this));
  };

  SomataService.prototype.sendResponse = function(client_id, message_id, response) {
    return this.binding.send(client_id, {
      id: message_id,
      kind: 'response',
      response: response
    });
  };

  SomataService.prototype.sendError = function(client_id, message_id, error) {
    if (error instanceof Error) {
      error = error.toString();
    }
    return this.binding.send(client_id, {
      id: message_id,
      kind: 'error',
      error: error
    });
  };

  SomataService.prototype.handleMethod = function(client_id, message) {
    var arity_mismatch, e, err, method_name, _method;
    if (VERBOSE) {
      log("<" + client_id + ">: " + (util.inspect(message, {
        depth: null
      })));
    }
    method_name = message.method;
    if (_method = this.getMethod(method_name)) {
      try {
        return _method.apply(null, __slice.call(message.args).concat([(function(_this) {
          return function(err, response) {
            if (err) {
              return _this.sendError(client_id, message.id, err);
            } else {
              return _this.sendResponse(client_id, message.id, response);
            }
          };
        })(this)]));
      } catch (_error) {
        e = _error;
        err = e.toString();
        arity_mismatch = message.args.length !== _method.length - 1;
        if (arity_mismatch && e instanceof TypeError && err.slice(11) === 'undefined is not a function') {
          err = "ArityError? method `" + method_name + "` takes " + (_method.length - 1) + " arguments.";
        }
        log.e('[Service.handleMethod] ERROR:' + err);
        console.error(e.stack);
        return this.sendError(client_id, message.id, err);
      }
    } else {
      log.e('[Service.handleMethod] ERROR: No method ' + message.method);
      return this.sendError(client_id, message.id, "No method " + message.method);
    }
  };

  SomataService.prototype.getMethod = function(method_name) {
    var method_context, _method;
    if (method_name[0] === '_') {
      _method = this[method_name];
      return _method;
    }
    if (typeof this.methods === 'function') {
      return this.methods(method_name);
    } else {
      if ((method_context = method_name.split('.')).length > 1) {
        return helpers.descend(this.methods, method_context);
      } else {
        return this.methods[method_name];
      }
    }
  };

  SomataService.prototype.subscriptions_by_event_name = {};

  SomataService.prototype.subscriptions_by_client = {};

  SomataService.prototype.handleSubscribe = function(client_id, message) {
    var event_name, subscription_id, subscription_key, _base, _base1;
    event_name = message.type;
    subscription_id = message.id;
    subscription_key = [client_id, subscription_id].join('::');
    if (VERBOSE) {
      log.i("[Service.handleSubscribe] Subscribing " + client_id + " <" + subscription_key + ">");
    }
    (_base = this.subscriptions_by_event_name)[event_name] || (_base[event_name] = []);
    if (__indexOf.call(this.subscriptions_by_event_name[event_name], subscription_key) < 0) {
      this.subscriptions_by_event_name[event_name].push(subscription_key);
      (_base1 = this.subscriptions_by_client)[client_id] || (_base1[client_id] = []);
      return this.subscriptions_by_client[client_id].push(subscription_key);
    }
  };

  SomataService.prototype.handleUnsubscribe = function(client_id, message) {
    var event_name, subscription_id, subscription_key, subscription_keys, _ref;
    event_name = message.type;
    subscription_id = message.id;
    subscription_key = [client_id, subscription_id].join('::');
    if (VERBOSE) {
      log.w("[Service.handleUnsubscribe] Unsubscribing <" + subscription_key + ">");
    }
    _ref = this.subscriptions_by_event_name;
    for (event_name in _ref) {
      subscription_keys = _ref[event_name];
      this.subscriptions_by_event_name[event_name] = _.without(subscription_keys, subscription_key);
    }
    return this.subscriptions_by_client[client_id] = _.without(this.subscriptions_by_client[client_id], subscription_key);
  };

  SomataService.prototype.publish = function(event_name, event) {
    return _.map(this.subscriptions_by_event_name[event_name], (function(_this) {
      return function(subscription_key) {
        var client_id, subscription_id, _ref;
        _ref = subscription_key.split('::'), client_id = _ref[0], subscription_id = _ref[1];
        return _this.sendEvent(client_id, subscription_id, event, event_name);
      };
    })(this));
  };

  SomataService.prototype.sendEvent = function(client_id, subscription_id, event, event_name) {
    if (VERBOSE) {
      log.d("[sendEvent] <" + client_id + "> " + subscription_id);
    }
    return this.binding.send(client_id, {
      id: subscription_id,
      kind: 'event',
      event: event
    });
  };

  SomataService.prototype.end = function(event_name) {
    _.map(this.subscriptions_by_event_name[event_name], (function(_this) {
      return function(subscription_key) {
        var client_id, subscription_id, _ref;
        _ref = subscription_key.split('::'), client_id = _ref[0], subscription_id = _ref[1];
        return _this.sendEnd(client_id, subscription_id);
      };
    })(this));
    return delete this.subscriptions_by_event_name[event_name];
  };

  SomataService.prototype.sendEnd = function(client_id, subscription_id) {
    return this.binding.send(client_id, {
      id: subscription_id,
      kind: 'end'
    });
  };

  SomataService.prototype._status = function(cb) {
    return usage.lookup(process.pid, {
      keepHistory: true
    }, function(err, _arg) {
      var cpu, memory, uptime;
      memory = _arg.memory, cpu = _arg.cpu;
      uptime = process.uptime();
      return cb(null, {
        memory: memory,
        cpu: cpu,
        uptime: uptime
      });
    });
  };

  SomataService.prototype.register = function() {
    this.registry_connection = new Connection({
      proto: this.registry_proto || REGISTRY_PROTO,
      host: this.registry_host || REGISTRY_HOST,
      port: this.registry_port || REGISTRY_PORT,
      service: {
        id: 'registry~s',
        name: 'registry'
      }
    });
    return this.registry_connection.on('connect', this.registryConnected.bind(this));
  };

  SomataService.prototype.registryConnected = function() {
    return this.sendRegister();
  };

  SomataService.prototype.sendRegister = function(cb) {
    var service_instance;
    service_instance = {
      id: this.id,
      name: this.name,
      proto: this.binding.proto,
      host: this.binding.host,
      port: this.binding.port,
      methods: Object.keys(this.methods)
    };
    return this.registry_connection.method('registerService', service_instance, (function(_this) {
      return function(err, registered) {
        log.s("Registered service `" + _this.id + "` on " + _this.binding.address);
        if (cb != null) {
          return cb(null, registered);
        }
      };
    })(this));
  };

  SomataService.prototype.deregister = function(cb) {
    if (this.registry_connection.timed_out) {
      log.e("[deregister] Registry is dead");
      if (cb != null) {
        return cb();
      }
    } else {
      this.registry_connection.method('deregisterService', this.name, this.id, (function(_this) {
        return function(err, deregistered) {
          log.e("[deregister] Deregistered `" + _this.id + "` from :" + _this.binding.port);
          if (cb != null) {
            return cb(null, deregistered);
          }
        };
      })(this));
      return this.registry_connection.on('failure', function() {
        log.e("[deregister] Registry is dead");
        if (cb != null) {
          return cb();
        }
      });
    }
  };

  return SomataService;

})(EventEmitter);
