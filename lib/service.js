// Generated by CoffeeScript 2.0.0-beta4
var Binding, Connection, EventEmitter, REGISTRY_HOST, REGISTRY_PORT, REGISTRY_PROTO, SERVICE_HOST, SERVICE_PORT, SERVICE_PROTO, SomataService, VERBOSE, _, emitters, helpers, log, usage, util,
  indexOf = [].indexOf;

util = require('util');

_ = require('underscore');

({EventEmitter} = require('events'));

usage = require('usage');

emitters = require('./events');

Binding = require('./binding');

Connection = require('./connection');

helpers = require('./helpers');

({log} = helpers);

VERBOSE = parseInt(process.env.SOMATA_VERBOSE || 0);

REGISTRY_PROTO = process.env.SOMATA_REGISTRY_PROTO || 'tcp';

REGISTRY_HOST = process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

REGISTRY_PORT = process.env.SOMATA_REGISTRY_PORT || 8420;

SERVICE_PROTO = process.env.SOMATA_SERVICE_PROTO;

SERVICE_HOST = process.env.SOMATA_SERVICE_HOST;

SERVICE_PORT = process.env.SOMATA_SERVICE_PORT;

module.exports = SomataService = (function() {
  class SomataService extends EventEmitter {
    // Instatiate a Somata service
    // --------------------------------------------------------------------------
    constructor(name, methods = {}, options = {}) {
      var base, base1, base2;
      super();
      this.name = name;
      this.methods = methods;
      this.id = this.name + '~' + helpers.randomString();
      // Determine options
      Object.assign(this, options);
      this.binding_options || (this.binding_options = {});
      (base = this.binding_options).proto || (base.proto = SERVICE_PROTO);
      (base1 = this.binding_options).host || (base1.host = SERVICE_HOST);
      (base2 = this.binding_options).port || (base2.port = SERVICE_PORT);
      // Bind and register the service
      this.bindRPC(() => {
        return this.register();
      });
      // Deregister when quit
      emitters.exit.onExit((cb) => {
        return this.deregister(cb);
      });
    }

    bindRPC(cb) {
      this.binding = new Binding(this.binding_options);
      this.binding.on('bind', cb);
      this.binding.on('method', this.handleMethod.bind(this));
      this.binding.on('subscribe', this.handleSubscribe.bind(this));
      return this.binding.on('unsubscribe', this.handleUnsubscribe.bind(this));
    }

    // Handle a remote method call
    // --------------------------------------------------------------------------

    // Helpers for sending response messages
    sendResponse(client_id, message_id, response) {
      return this.binding.send(client_id, {
        id: message_id,
        kind: 'response',
        response: response
      });
    }

    sendError(client_id, message_id, error) {
      if (error instanceof Error) {
        error = error.toString();
      }
      return this.binding.send(client_id, {
        id: message_id,
        kind: 'error',
        error: error
      });
    }

    // Interpreting a method call
    handleMethod(client_id, message) {
      var _method, arity_mismatch, e, err, method_name;
      if (VERBOSE) {
        log(`<${client_id}>: ${util.inspect(message, {
          depth: null
        })}`);
      }
      // Find the method
      method_name = message.method;
      if (_method = this.getMethod(method_name)) {
        try {
          // Execute the named method with given arguments
          return _method(...message.args, (err, response) => {
            if (err) {
              return this.sendError(client_id, message.id, err);
            } else {
              return this.sendResponse(client_id, message.id, response);
            }
          });
        } catch (error1) {
          // Catch unhandled errors
          e = error1;
          err = e.toString();
          arity_mismatch = message.args.length !== _method.length - 1;
          if (arity_mismatch && e instanceof TypeError && err.slice(11) === 'undefined is not a function') {
            err = `ArityError? method \`${method_name}\` takes ${_method.length - 1} arguments.`;
          }
          log.e('[Service.handleMethod] ERROR:' + err);
          console.error(e.stack);
          return this.sendError(client_id, message.id, err);
        }
      } else {
        // Method not found for this service
        log.e('[Service.handleMethod] ERROR: No method ' + message.method);
        return this.sendError(client_id, message.id, "No method " + message.method);
      }
    }

    // Finding a method from the methods hash
    getMethod(method_name) {
      var _method, method_context;
      // Look for builtins, having method names starting with a `_`
      if (method_name[0] === '_') {
        //method_name = method_name.slice(1)
        _method = this[method_name];
        return _method;
      }
      if (typeof this.methods === 'function') {
        return this.methods(method_name);
      } else {
        // Get a deeper level method from @methods
        if ((method_context = method_name.split('.')).length > 1) {
          return helpers.descend(this.methods, method_context);
        } else {
          // Get a method from @methods
          return this.methods[method_name];
        }
      }
    }

    handleSubscribe(client_id, message) {
      var base, base1, event_name, subscription_id, subscription_key;
      event_name = message.type;
      subscription_id = message.id;
      subscription_key = [client_id, subscription_id].join('::');
      if (VERBOSE) {
        log.i(`[Service.handleSubscribe] Subscribing ${client_id} <${subscription_key}>`);
      }
      (base = this.subscriptions_by_event_name)[event_name] || (base[event_name] = []);
      if (indexOf.call(this.subscriptions_by_event_name[event_name], subscription_key) < 0) {
        this.subscriptions_by_event_name[event_name].push(subscription_key);
        (base1 = this.subscriptions_by_client)[client_id] || (base1[client_id] = []);
        return this.subscriptions_by_client[client_id].push(subscription_key);
      }
    }

    handleUnsubscribe(client_id, message) {
      var event_name, ref, subscription_id, subscription_key, subscription_keys;
      event_name = message.type;
      subscription_id = message.id;
      subscription_key = [client_id, subscription_id].join('::');
      if (VERBOSE) {
        log.w(`[Service.handleUnsubscribe] Unsubscribing <${subscription_key}>`);
      }
      ref = this.subscriptions_by_event_name;
      // TODO: Improve how subscriptions are stored
      for (event_name in ref) {
        subscription_keys = ref[event_name];
        this.subscriptions_by_event_name[event_name] = _.without(subscription_keys, subscription_key);
      }
      return this.subscriptions_by_client[client_id] = _.without(this.subscriptions_by_client[client_id], subscription_key);
    }

    publish(event_name, event) {
      return _.map(this.subscriptions_by_event_name[event_name], (subscription_key) => {
        var client_id, subscription_id;
        [client_id, subscription_id] = subscription_key.split('::');
        return this.sendEvent(client_id, subscription_id, event, event_name);
      });
    }

    sendEvent(client_id, subscription_id, event, event_name) {
      if (VERBOSE) {
        log.d(`[sendEvent] <${client_id}> ${subscription_id}`);
      }
      return this.binding.send(client_id, {
        id: subscription_id,
        kind: 'event',
        event: event
      });
    }

    end(event_name) {
      _.map(this.subscriptions_by_event_name[event_name], (subscription_key) => {
        var client_id, subscription_id;
        [client_id, subscription_id] = subscription_key.split('::');
        return this.sendEnd(client_id, subscription_id);
      });
      return delete this.subscriptions_by_event_name[event_name];
    }

    sendEnd(client_id, subscription_id) {
      return this.binding.send(client_id, {
        id: subscription_id,
        kind: 'end'
      });
    }

    // Handle a status request
    // --------------------------------------------------------------------------
    _status(cb) {
      return usage.lookup(process.pid, {
        keepHistory: true
      }, function(err, {memory, cpu}) {
        var uptime;
        uptime = process.uptime();
        return cb(null, {memory, cpu, uptime});
      });
    }

    // Register and deregister the service from the registry
    // --------------------------------------------------------------------------
    register() {
      this.registry_connection = new Connection({
        proto: this.registry_proto || REGISTRY_PROTO,
        host: this.registry_host || REGISTRY_HOST,
        port: this.registry_port || REGISTRY_PORT,
        service: {
          id: 'registry~s',
          name: 'registry'
        }
      });
      return this.registry_connection.on('connect', this.registryConnected.bind(this));
    }

    registryConnected() {
      // TODO: Consider re-subscriptions from clients
      return this.sendRegister();
    }

    sendRegister(cb) {
      var service_instance;
      service_instance = {
        id: this.id,
        name: this.name,
        heartbeat: this.heartbeat,
        proto: this.binding.proto,
        host: this.binding.host,
        port: this.binding.port,
        methods: Object.keys(this.methods)
      };
      return this.registry_connection.method('registerService', service_instance, (err, registered) => {
        log.s(`Registered service \`${this.id}\` on ${this.binding.address}`);
        if (cb != null) {
          return cb(null, registered);
        }
      });
    }

    deregister(cb) {
      if (this.registry_connection.timed_out) {
        log.e("[deregister] Registry is dead");
        if (cb != null) {
          return cb();
        }
      } else {
        this.registry_connection.method('deregisterService', this.name, this.id, (err, deregistered) => {
          log.e(`[deregister] Deregistered \`${this.id}\` from :${this.binding.port}`);
          if (cb != null) {
            return cb(null, deregistered);
          }
        });
        return this.registry_connection.on('failure', function() {
          log.e("[deregister] Registry is dead");
          if (cb != null) {
            return cb();
          }
        });
      }
    }

  };

  // Handle a subscription
  // --------------------------------------------------------------------------
  SomataService.prototype.subscriptions_by_event_name = {};

  SomataService.prototype.subscriptions_by_client = {};

  return SomataService;

})();
